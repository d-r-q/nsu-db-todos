package examplies.proxy

import org.springframework.data.repository.CrudRepository
import java.lang.reflect.InvocationHandler
import java.lang.reflect.Method
import java.lang.reflect.ParameterizedType
import java.lang.reflect.Proxy
import javax.persistence.Entity


// Сущность, для которой заводим репоз
@Entity(name = "users")
data class User(val id: Long, val name: String)

// Собственно сам репоз, он должен расширять CrudRepository
interface UserJpaRepo : CrudRepository<User, Long> {

    // Метод который мы реализуем с помощью магии рефлексии
    fun findByName(name: String): List<User>

}

class JpaRepoProxy(val db: db) : InvocationHandler {

    override fun invoke(proxy: Any, method: Method, args: Array<out Any>?): Any {
        // Сначала Spring Data JPA использует магию рефлекшена, для того чтобы понять объекты какого класса можно
        // вытянуть с использованием текущего репозитория

        // Сначала достаём класс объекта на котором был вызван метод findByName, это сгенерированный Proxy0
        val autoGeneratedProxyClass = proxy::class.java
        println("autoGeneratedProxyClass: $autoGeneratedProxyClass ")

        // Он реализует наш интерфейс JpaRepo
        val userJpaRepoClass = autoGeneratedProxyClass.genericInterfaces[0] as Class<*>
        println("jpaRepoClass: $userJpaRepoClass ")

        // Который в свою очередь расширяет CrudRepository
        val crudRepositoryClass = userJpaRepoClass.genericInterfaces[0] as ParameterizedType
        println("crudRepositoryClass: $crudRepositoryClass ")

        // У котрого, наконец проставлен тип объектов, которые нам надо вернуть (CrudRepository< ->User<- , Long>)
        val userClass = crudRepositoryClass.actualTypeArguments[0] as Class<*>
        println("userClass: $userClass ")

        // А у этого класса, есть аннотация с именем сущности
        val entity = (userClass.annotations[0] as Entity).name

        // Затем у них есть небольшой парсер строк вида "findByNameAndActiveTrueOrSomethingOrderByName"
        val field = method.name.substring("findBy".length)

        // Который они уже используют для построения запроса уже на базе JPA (без Spring Data)
        // вообще у них вроде запрос строится через объектное АПИ, но мы симитируем построение запроса на JPQL (!= SQL)
        val jpql = "select from $entity where $field = ?"

        // Сформированный запрос передаётся в EntityManager, который уже выполняет работу по генерации и исполнению
        // sql-запроса и отображения его результата в объекты
        return db.exec(jpql)
    }

}

inline fun <reified T> createTrxProxy(db: db): T {

    return Proxy.newProxyInstance(
        T::class.java.classLoader,
        arrayOf(T::class.java),
        JpaRepoProxy(db)
    ) as T

}

fun main() {
    val repo = createTrxProxy<UserJpaRepo>(db)
    println(repo.findByName("name"))
}